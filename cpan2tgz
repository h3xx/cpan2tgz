#!/usr/bin/perl
# 
# cpan2tgz - create slackware packages from cpan distributions 
# 
# Jason Woodward
# woodwardj at jaos dot org
# http://software.jaos.org
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
use strict;
use warnings;
use Config;
use CPAN;
use Getopt::Long;

our $VERSION = "0.2";

$ENV{PATH} = "/bin:/sbin:/usr/bin:/usr/sbin";
my (%PACKAGE_CACHE_LIST,$recursive,$install_after_building,$ignore_installed_deps);

usage() unless
	GetOptions(
		"recursive" => \$recursive,
		"ignoreinstalled" => \$ignore_installed_deps,
		"install"	=> \$install_after_building,
	);

usage() unless (scalar(@ARGV) > 0);

foreach my $mod (@ARGV){
	do_package($mod);
}

sub do_package {
	my ($module_name) = @_;
	return unless $module_name;

	my $module = CPAN::Shell->expand('Module',$module_name);
	unless($module){
		print STDERR "\nFailed to find module: $module_name","\n";
		exit(1);
	}

	print "\n\nProcessing $module_name...\n\n";
	$PACKAGE_CACHE_LIST{$module->id()} = 1;

	# try to extract some info about the module
	my $pkg_name = "perl-" . lc((split('/',$module->cpan_file))[-1]);
	my $final_pkg_version = (split('-',$pkg_name))[-1];
	(my $final_pkg_name = $pkg_name) =~ s/\-$final_pkg_version//;
	$pkg_name =~ s/\.tar.*?$//;
	if( $module->xs_file() ){
		$pkg_name .= "-" . [split('-',$Config{archname})]->[0];
	}else{
		$pkg_name .= "-noarch";
	}
	$pkg_name .= "-1.tgz";
	$pkg_name = lc($pkg_name);

	my $dest_dir = "/tmp/" . $module->id();

	# do an initial make so that we can get the dep info
	my $pack = $CPAN::META->instance('CPAN::Distribution',$module->cpan_file());
	die "Failed to initialize CPAN::Distribution object for $module_name: $!" unless $pack;
	eval { $pack->make() or die $!; };
	if( $@ ){
		print "make ERROR [$module_name]: $!\n";
		exit(1);
	}

	my @deps;
	if( $ignore_installed_deps ){
		# only get the deps that are not installed
		@deps = grep { m/\w+/; } map { eval "no warnings 'all'; use $_;"; if($@){ $_ } } keys %{$pack->prereq_pm()};
	}else{
		# get all dependencies
		@deps = keys %{$pack->prereq_pm()};
	}
	# look at module prerequisites
	if( @deps > 0 ){
		if($recursive){
			print "\n\nhandling " . scalar(@deps)
				. " deps for $module_name: ",join(", ",@deps),"\n\n";
			sleep(1);
			foreach my $dep ( @deps ){
				local $@;
				next if defined $PACKAGE_CACHE_LIST{$dep};
				print "FIXME: I don't deal with xsloader b/c make ?n/a?\n",next if $dep =~ m/xsloader/i;
				eval "no warnings 'all';use $dep;";
				next if ( $ignore_installed_deps && !$@ );
				do_package($dep);
			}
		}else{
			print "\n\nStopping.\n[", $module->id(), "] requires ", join(", ",@deps),"\n";
			exit(1);
		}
	}

	clear_build_dir($dest_dir);
	
	# here we do steps to cleanup source before we build (per LinuxPackages.net perfect packages instructions)
	system("cd " . $pack->dir() . " && chown -R root.root .");
	system("cd " . $pack->dir() . " && find . -perm 777 -exec chmod 755 {} \\;");
	system("cd " . $pack->dir() . " && find . -perm 555 -exec chmod 755 {} \\;");
	system("cd " . $pack->dir() . " && find . -perm 444 -exec chmod 644 {} \\;");
	system("cd " . $pack->dir() . " && find . -perm 666 -exec chmod 644 {} \\;");
	system("cd " . $pack->dir() . " && find . -perm 664 -exec chmod 644 {} \\;");

	# install to the package build dir
	system("cd " . $pack->dir() . " && make install DESTDIR=$dest_dir");
	die "Failed to install to $dest_dir: $!" unless ( -d $dest_dir );

	# copy documentation to the package build dir
	system("cd $dest_dir && mkdir -p ./usr/doc/$final_pkg_name-" . $module->cpan_version);
	system("cd " . $pack->dir() . " && find . -iregex '.*readme.*' -o -iregex '.*change.*' -o -iregex '.*todo.*' -o -iregex '.*license.*' -o -iregex '.*copying.*' -o -iregex '.*install.*' -o -iregex '.*\.txt' -o -iregex '.*\.html' |xargs -r -iZ cp Z $dest_dir/usr/doc/$final_pkg_name-" . $module->cpan_version . "/");

	# build a shell script to fixup the package like Pat's Perl SlackBuild
	open(my $script_fh,">$dest_dir/build.sh") or die "Failed to open build.sh for writing: $!";
	print $script_fh "cd $dest_dir\n";
	print $script_fh "find . | xargs file | grep 'executable' | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null\n";
	print $script_fh "find . | xargs file | grep 'shared object' | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null\n";
	print $script_fh "find ./usr/share/man/ -name '*.3' -exec gzip -9 {} \\; 2> /dev/null\n";
	print $script_fh "find ./usr/share/man/ -name '*.1' -exec gzip -9 {} \\; 2> /dev/null\n";
	print $script_fh "mv ./usr/share/man ./usr/\n" if( -d "$dest_dir/usr/share/man" );
	print $script_fh "chown -R root.bin ./usr/bin\n" if( -d "$dest_dir/usr/bin" );
	print $script_fh "chmod 755 ./usr/bin/*\n" if( -d "$dest_dir/usr/bin");
	print $script_fh "chmod 644 ./usr/man/man?/*\n" if( -d "$dest_dir/usr/man" );
	print $script_fh "rmdir ./usr/share\n" if( -d "$dest_dir/usr/share" );
	print $script_fh "mkdir ./install\n";
	# generate the doinst.sh to fix perllocal.pod
	print $script_fh <<SCRIPT
PERLLOCALPOD=\`find . -name perllocal.pod\`
cat >./install/doinst.sh <<EOF
#!/bin/sh

cat >> \${PERLLOCALPOD/.\\//} <<PLP

EOF
cat \$PERLLOCALPOD >>install/doinst.sh
echo "PLP" >>install/doinst.sh
rm \$PERLLOCALPOD
SCRIPT
;

	close($script_fh);
	system("cd $dest_dir && sh build.sh");
	system("cd $dest_dir && rm build.sh");

	
	# generate the slack-required file
	open(my $required_fh,">$dest_dir/install/slack-required") or die "Failed to open slack-required for writing: $!";
	print $required_fh "perl\n";
	# use the hashref here so we can get the version
	my $deps = $pack->prereq_pm();
	foreach my $perl_mod_dep ( keys %{$deps} ){
		my $version = $deps->{$perl_mod_dep};
		(my $pmd = $perl_mod_dep) =~ s/\:\:/\-/g;
		if( int($version) > 0 ){
			print $required_fh "perl-$pmd >= $version\n";
		}else{
			print $required_fh "perl-$pmd\n";
		}
	}
	close($required_fh);

	# generate the slack-desc file
	open(my $desc_fh,">$dest_dir/install/slack-desc") or die "Failed to open slack-desc for writing: $!";
	print $desc_fh "\n";
	print $desc_fh "# HOW TO EDIT THIS FILE:\n";
	print $desc_fh "# The \"handy ruler\" below makes it easier to edit a package description.  Line\n";
	print $desc_fh "# up the first '|' above the ':' following the base package name, and the '|'\n";
	print $desc_fh "# on the right side marks the last column you can put a character in.  You must\n";
	print $desc_fh "# make exactly 11 lines for the formatting to be correct.  It's also\n";
	print $desc_fh "# customary to leave one space after the ':'.\n";
	print $desc_fh "\n";
	print $desc_fh "         |-----handy-ruler------------------------------------------------------|\n";
	print $desc_fh "$final_pkg_name: $final_pkg_name " . $module->cpan_version() . " (Perl module)\n";
	print $desc_fh "$final_pkg_name:  \n";
	print $desc_fh "$final_pkg_name:  Packaged by cpan2tgz\n";
	print $desc_fh "$final_pkg_name:  \n";
	print $desc_fh "$final_pkg_name:  cpan2tgz by Jason Woodward <woodwardj\@jaos.org>\n";
	print $desc_fh "$final_pkg_name:  \n";
	print $desc_fh "$final_pkg_name:  \n";
	print $desc_fh "$final_pkg_name:  \n";
	print $desc_fh "$final_pkg_name:  \n";
	print $desc_fh "$final_pkg_name:  http://software.jaos.org/\n";
	print $desc_fh "$final_pkg_name:  \n";
	close($desc_fh);

	# finally, build the package
	system("cd $dest_dir && makepkg -l y -c n /usr/src/$pkg_name");
	die "Failed to build package $pkg_name: $!" unless ( -f "/usr/src/$pkg_name" );

	# install the package
	if( $recursive or $install_after_building ){
		system("installpkg /usr/src/$pkg_name");
	}

	clear_build_dir($dest_dir);

}

sub usage {
	print "Jason Woodward <woodwardj at jaos dot org>\n";
	print "Usage: $0 [option(s)] [modules(s)]\n";
	print "  --recursive        build required modules","\n";
	print "                     this requires installing required modules\n";
	print "                     as it traverses the dependency tree (DANGEROUS)\n";
	print "  --ignoreinstalled  don't build installed required modules","\n";
	print "                     this only works with --recursive\n";
	print "  --install          always install the generated package\n";
	print "                     this is on for --recursive by default\n";

	exit(1);
}

sub clear_build_dir {
	my ($dest_dir) = @_;
	return unless $dest_dir;
	system("rm -r $dest_dir/*") if ( -d $dest_dir );
	system("rmdir $dest_dir") if ( -d $dest_dir );
}

1;

__END__

=head1 NAME

cpan2tgz - create Slackware GNU/Linux packages from CPAN Perl module distributions

=head1 SYNOPSIS

cpan2tgz [option(s)] [module(s)]

options: [--recursive] [--ignoreinstalled] [--install]

=head1 DESCRIPTION

cpan2tgz is a tool to create Slackware GNU/Linux packages from CPAN Perl module distributions.  cpan2tgz was inspired by cpan2rpm.

=head1 OPTIONS

=over

=item B<--recursive>

Download the package only.  Do not install/upgrade.  Packages are downloaded to /var/slapt-get/.   This will build required modules and then install them as it traverses the dependency tree of the specified Perl module.  This can be dangerous.  It might be best to install one at a time.

=item B<--ignoreinstalled>

This option specifies not to build packages for required modules if the module is found to be present and installed on the system.  This only works in conjunction with --recursive.

=item B<--install>

Always install the generated package.  This is the default behavior with --recursive.

=item B<module(s)>

A series of Perl modules to install, ie Data::Dumper

=head1 NOTES

cpan2tgz uses the CPAN Perl module.  A working CPAN/Config.pm is assumed.  If CPAN has not been initialized prior to running cpan2tgz, it will be initialized on the first run.

=head1 AUTHOR

Jason Woodward <woodwardj@jaos.org>

http://software.jaos.org/

=head1 SEE ALSO

installpkg(8), makepkg(8), removepkg(8), pkgtool(8), upgradepkg(8),

=pod OSNAMES

any

=pod SCRIPT CATEGORIES

Unix/System_administration

=cut
